<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Intermolecular Forces Visualization</title>
    <link href="https://fonts.googleapis.com/css2?family=Roboto:wght@300;400;500;700&display=swap" rel="stylesheet">
    <link href="https://fonts.googleapis.com/icon?family=Material+Icons" rel="stylesheet">
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            margin: 0;
            overflow: hidden;
            font-family: 'Roboto', sans-serif;
            color: #333;
            background-color: #f5f5f5;
        }

        #container {
            position: relative;
            width: 100%;
            height: 100vh;
        }

        #info-panel {
            position: absolute;
            top: 20px;
            left: 20px;
            background: rgba(255, 255, 255, 0.95);
            color: #333;
            padding: 20px;
            border-radius: 8px;
            max-width: 360px;
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.15);
            transition: all 0.3s ease;
            backdrop-filter: blur(10px);
            z-index: 10;
        }

        #info-panel h2 {
            margin: 0 0 12px 0;
            font-weight: 500;
            color: #1976d2;
            font-size: 1.5rem;
        }

        #description {
            font-size: 0.95rem;
            line-height: 1.5;
            margin-bottom: 0;
        }

        #controls-container {
            position: absolute;
            bottom: 20px;
            left: 20px;
            right: 20px;
            display: flex;
            justify-content: center;
            z-index: 10;
        }

        #controls {
            background: rgba(255, 255, 255, 0.95);
            backdrop-filter: blur(10px);
            padding: 16px 24px;
            border-radius: 8px;
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.15);
            display: flex;
            flex-wrap: wrap;
            justify-content: center;
            gap: 12px;
        }

        .material-button {
            min-width: 150px;
            padding: 10px 16px;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-family: 'Roboto', sans-serif;
            font-size: 0.9rem;
            font-weight: 500;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.2s ease;
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.2);
        }

        .material-button:hover {
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.3);
            transform: translateY(-2px);
        }

        .material-button:active {
            box-shadow: 0 1px 3px rgba(0, 0, 0, 0.2);
            transform: translateY(1px);
        }

        .material-button i {
            margin-right: 8px;
        }

        .primary {
            background-color: #1976d2;
            color: white;
        }

        .primary:hover {
            background-color: #1565c0;
        }

        .secondary {
            background-color: #f50057;
            color: white;
        }

        .secondary:hover {
            background-color: #c51162;
        }

        .tertiary {
            background-color: #00bcd4;
            color: white;
        }

        .tertiary:hover {
            background-color: #00acc1;
        }

        .neutral {
            background-color: #616161;
            color: white;
        }

        .neutral:hover {
            background-color: #424242;
        }

        .quaternary {
            background-color: #9c27b0;
            color: white;
        }

        .quaternary:hover {
            background-color: #7b1fa2;
        }

        #loading {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(255, 255, 255, 0.9);
            color: #1976d2;
            font-size: 20px;
            padding: 24px 40px;
            border-radius: 8px;
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.2);
            display: flex;
            align-items: center;
            z-index: 100;
        }

        #loading .spinner {
            border: 4px solid rgba(25, 118, 210, 0.3);
            border-radius: 50%;
            border-top: 4px solid #1976d2;
            width: 24px;
            height: 24px;
            margin-right: 16px;
            animation: spin 1s linear infinite;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        @media (max-width: 768px) {
            #info-panel {
                top: 10px;
                left: 10px;
                right: 10px;
                max-width: none;
            }

            #controls {
                flex-direction: column;
                width: 100%;
                gap: 8px;
            }

            .material-button {
                width: 100%;
            }
        }

        .active-button {
            box-shadow: 0 0 0 3px rgba(25, 118, 210, 0.5);
            position: relative;
            z-index: 1;
        }

        .tooltip {
            position: relative;
        }

        .tooltip .tooltip-text {
            visibility: hidden;
            width: 200px;
            background-color: rgba(0, 0, 0, 0.8);
            color: #fff;
            text-align: center;
            border-radius: 6px;
            padding: 8px;
            position: absolute;
            z-index: 1;
            bottom: 125%;
            left: 50%;
            transform: translateX(-50%);
            opacity: 0;
            transition: opacity 0.3s;
            font-weight: normal;
            text-transform: none;
            letter-spacing: normal;
            font-size: 0.8rem;
        }

        .tooltip:hover .tooltip-text {
            visibility: visible;
            opacity: 1;
        }
    </style>
</head>
<body>
    <div id="container">
        <div id="info-panel">
            <h2>Intermolecular Forces Visualization</h2>
            <p id="description">Select a type of intermolecular force to visualize.</p>
        </div>
        <div id="controls-container">
            <div id="controls">
                <button id="hBond" class="material-button primary tooltip">
                    <i class="material-icons">water_drop</i>
                    Hydrogen Bonding
                    <span class="tooltip-text">Visualize hydrogen bonding between water molecules</span>
                </button>
                <button id="dipole" class="material-button secondary tooltip">
                    <i class="material-icons">electric_bolt</i>
                    Dipole-Dipole
                    <span class="tooltip-text">Visualize dipole-dipole interactions between polar molecules</span>
                </button>
                <button id="polarizability" class="material-button tertiary tooltip">
                    <i class="material-icons">bubble_chart</i>
                    Polarizability
                    <span class="tooltip-text">Visualize London dispersion forces and electron cloud distortion</span>
                </button>
                <button id="ionDipole" class="material-button quaternary tooltip">
                    <i class="material-icons">add_circle</i>
                    Ion-Dipole
                    <span class="tooltip-text">Visualize ion-dipole interactions between ions and polar molecules</span>
                </button>
                <button id="reset" class="material-button neutral tooltip">
                    <i class="material-icons">restart_alt</i>
                    Reset View
                    <span class="tooltip-text">Reset the camera to the initial position</span>
                </button>
            </div>
        </div>
        <div id="loading">
            <div class="spinner"></div>
            <span>Loading visualization...</span>
        </div>
    </div>
    <script type="importmap">
        {
            "imports": {
                "three": "../js/three.module.js",
                "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
            }
        }
    </script>
    <script type="module">

        import * as THREE from 'https://cdn.jsdelivr.net/npm/three@0.157.0/build/three.module.js';
        import { OrbitControls } from 'https://cdn.jsdelivr.net/npm/three@0.157.0/examples/jsm/controls/OrbitControls.js';
        import { TextGeometry } from 'https://cdn.jsdelivr.net/npm/three@0.157.0/examples/jsm/geometries/TextGeometry.js';
        import { FontLoader } from 'https://cdn.jsdelivr.net/npm/three@0.157.0/examples/jsm/loaders/FontLoader.js';

        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0x111122);

        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.z = 20;

        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(window.devicePixelRatio);
        document.getElementById('container').appendChild(renderer.domElement);

        const controls = new OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true;
        controls.dampingFactor = 0.05;

        const ambientLight = new THREE.AmbientLight(0x404040);
        scene.add(ambientLight);

        const directionalLight = new THREE.DirectionalLight(0xffffff, 0.5);
        directionalLight.position.set(1, 1, 1);
        scene.add(directionalLight);

        const moleculeGroup = new THREE.Group();
        scene.add(moleculeGroup);

        const textGroup = new THREE.Group();
        scene.add(textGroup);

        const hydrogenMaterial = new THREE.MeshStandardMaterial({ color: 0xFFFFFF, metalness: 0.3, roughness: 0.4 });
        const oxygenMaterial = new THREE.MeshStandardMaterial({ color: 0xFF0000, metalness: 0.3, roughness: 0.4 });
        const nitrogenMaterial = new THREE.MeshStandardMaterial({ color: 0x3050FF, metalness: 0.3, roughness: 0.4 });
        const carbonMaterial = new THREE.MeshStandardMaterial({ color: 0x333333, metalness: 0.3, roughness: 0.4 });
        const bondMaterial = new THREE.MeshStandardMaterial({ color: 0xCCCCCC, metalness: 0.3, roughness: 0.7 });
        const sodiumMaterial = new THREE.MeshStandardMaterial({ color: 0xBFA500, metalness: 0.5, roughness: 0.3 });
        const chlorideMaterial = new THREE.MeshStandardMaterial({ color: 0x00FF00, metalness: 0.3, roughness: 0.5 });

        const positiveChargeMaterial = new THREE.MeshStandardMaterial({ 
            color: 0xFF5555, 
            transparent: true, 
            opacity: 0.7,
            metalness: 0.3, 
            roughness: 0.4 
        });

        const negativeChargeMaterial = new THREE.MeshStandardMaterial({ 
            color: 0x5555FF, 
            transparent: true, 
            opacity: 0.7,
            metalness: 0.3, 
            roughness: 0.4 
        });

        const textMaterial = new THREE.MeshPhongMaterial({ 
            color: 0xffffff,
            emissive: 0x222222,
            specular: 0xffffff,
            shininess: 100
        });

        const hydrogenGeometry = new THREE.SphereGeometry(0.5, 32, 32);
        const oxygenGeometry = new THREE.SphereGeometry(0.8, 32, 32);
        const nitrogenGeometry = new THREE.SphereGeometry(0.7, 32, 32);
        const carbonGeometry = new THREE.SphereGeometry(0.7, 32, 32);
        const ionGeometry = new THREE.SphereGeometry(1.0, 32, 32);

        const arrowHelper = new THREE.Group();
        scene.add(arrowHelper);

        const electronCloudGroup = new THREE.Group();
        scene.add(electronCloudGroup);

        const electricFieldGroup = new THREE.Group();
        scene.add(electricFieldGroup);

        let currentMode = '';
        let animationFrameId = null;
        let animationTime = 0;
        let font = null;

        const fontLoader = new FontLoader();
        fontLoader.load('https://cdn.jsdelivr.net/npm/three@0.157.0/examples/fonts/helvetiker_bold.typeface.json', function(loadedFont) {
            font = loadedFont;

            visualizeHydrogenBonding();

            document.getElementById('loading').style.display = 'none';
        });

        function clearScene() {
            while(moleculeGroup.children.length > 0) { 
                moleculeGroup.remove(moleculeGroup.children[0]); 
            }

            while(arrowHelper.children.length > 0) {
                arrowHelper.remove(arrowHelper.children[0]);
            }

            while(electronCloudGroup.children.length > 0) {
                electronCloudGroup.remove(electronCloudGroup.children[0]);
            }

            while(textGroup.children.length > 0) {
                textGroup.remove(textGroup.children[0]);
            }

            while(electricFieldGroup.children.length > 0) {
                electricFieldGroup.remove(electricFieldGroup.children[0]);
            }

            if (animationFrameId) {
                cancelAnimationFrame(animationFrameId);
                animationFrameId = null;
            }

            animationTime = 0;
        }

        function createBond(startPosition, endPosition, radius = 0.2) {
            const direction = new THREE.Vector3().subVectors(endPosition, startPosition);
            const length = direction.length();

            const bondGeometry = new THREE.CylinderGeometry(radius, radius, length, 16);
            bondGeometry.translate(0, length / 2, 0);

            const bond = new THREE.Mesh(bondGeometry, bondMaterial);
            bond.position.copy(startPosition);

            const quaternion = new THREE.Quaternion();
            quaternion.setFromUnitVectors(new THREE.Vector3(0, 1, 0), direction.normalize());
            bond.setRotationFromQuaternion(quaternion);

            return bond;
        }

        function createDottedBond(startPosition, endPosition, segments = 10, radius = 0.1) {
            const bondGroup = new THREE.Group();
            const direction = new THREE.Vector3().subVectors(endPosition, startPosition);
            const length = direction.length();
            const segmentLength = length / (segments * 2); 

            const unitDirection = direction.clone().normalize();

            for(let i = 0; i < segments; i++) {
                const segmentStart = new THREE.Vector3().copy(startPosition).addScaledVector(unitDirection, i * 2 * segmentLength);
                const segmentEnd = new THREE.Vector3().copy(segmentStart).addScaledVector(unitDirection, segmentLength);

                const bondSegment = createBond(segmentStart, segmentEnd, radius);
                bondSegment.material = new THREE.MeshBasicMaterial({ 
                    color: 0x00FFFF, 
                    transparent: true, 
                    opacity: 0.7
                });

                bondGroup.add(bondSegment);
            }

            return bondGroup;
        }

        function create3DText(text, size = 0.5, position = { x: 0, y: 0, z: 0 }, rotation = { x: 0, y: 0, z: 0 }) {
            if (!font) return null;

            const textGeometry = new TextGeometry(text, {
                font: font,
                size: size,
                height: size * 0.2,
                curveSegments: 12,
                bevelEnabled: true,
                bevelThickness: size * 0.05,
                bevelSize: size * 0.02,
                bevelOffset: 0,
                bevelSegments: 5
            });

            textGeometry.computeBoundingBox();
            const textWidth = textGeometry.boundingBox.max.x - textGeometry.boundingBox.min.x;
            textGeometry.translate(-textWidth/2, 0, 0);

            const textMesh = new THREE.Mesh(textGeometry, textMaterial.clone());
            textMesh.position.set(position.x, position.y, position.z);
            textMesh.rotation.set(rotation.x, rotation.y, rotation.z);
            textMesh.userData = { isRainbowText: true };

            textGroup.add(textMesh);

            return textMesh;
        }

        function updateRainbowEffect(elapsedTime) {
            textGroup.children.forEach(textMesh => {
                if (textMesh.userData && textMesh.userData.isRainbowText) {

                    const hue = (elapsedTime * 0.1) % 1;
                    textMesh.material.color.setHSL(hue, 0.8, 0.5);
                    textMesh.material.emissive.setHSL(hue, 0.5, 0.2);
                }
            });
        }

        function createWaterMolecule(position = new THREE.Vector3(0, 0, 0), rotation = new THREE.Euler(0, 0, 0)) {
            const molecule = new THREE.Group();
            molecule.position.copy(position);
            molecule.rotation.copy(rotation);

            const oxygen = new THREE.Mesh(oxygenGeometry, oxygenMaterial);
            molecule.add(oxygen);

            const hydrogen1 = new THREE.Mesh(hydrogenGeometry, hydrogenMaterial);
            hydrogen1.position.set(-0.8, 0.5, 0);
            molecule.add(hydrogen1);

            const hydrogen2 = new THREE.Mesh(hydrogenGeometry, hydrogenMaterial);
            hydrogen2.position.set(0.8, 0.5, 0);
            molecule.add(hydrogen2);

            const bond1 = createBond(oxygen.position, hydrogen1.position);
            molecule.add(bond1);

            const bond2 = createBond(oxygen.position, hydrogen2.position);
            molecule.add(bond2);

            return molecule;
        }

        function createAmmoniaMolecule(position = new THREE.Vector3(0, 0, 0), rotation = new THREE.Euler(0, 0, 0)) {
            const molecule = new THREE.Group();
            molecule.position.copy(position);
            molecule.rotation.copy(rotation);

            const nitrogen = new THREE.Mesh(nitrogenGeometry, nitrogenMaterial);
            molecule.add(nitrogen);

            const hydrogen1 = new THREE.Mesh(hydrogenGeometry, hydrogenMaterial);
            hydrogen1.position.set(-0.8, 0.5, 0);
            molecule.add(hydrogen1);

            const hydrogen2 = new THREE.Mesh(hydrogenGeometry, hydrogenMaterial);
            hydrogen2.position.set(0.4, 0.5, 0.7);
            molecule.add(hydrogen2);

            const hydrogen3 = new THREE.Mesh(hydrogenGeometry, hydrogenMaterial);
            hydrogen3.position.set(0.4, 0.5, -0.7);
            molecule.add(hydrogen3);

            const bond1 = createBond(nitrogen.position, hydrogen1.position);
            molecule.add(bond1);

            const bond2 = createBond(nitrogen.position, hydrogen2.position);
            molecule.add(bond2);

            const bond3 = createBond(nitrogen.position, hydrogen3.position);
            molecule.add(bond3);

            return molecule;
        }

        function createMethaneMolecule(position = new THREE.Vector3(0, 0, 0), rotation = new THREE.Euler(0, 0, 0)) {
            const molecule = new THREE.Group();
            molecule.position.copy(position);
            molecule.rotation.copy(rotation);

            const carbon = new THREE.Mesh(carbonGeometry, carbonMaterial);
            molecule.add(carbon);

            const hydrogenPositions = [
                new THREE.Vector3(0.6, 0.6, 0.6),
                new THREE.Vector3(-0.6, 0.6, -0.6),
                new THREE.Vector3(0.6, -0.6, -0.6),
                new THREE.Vector3(-0.6, -0.6, 0.6)
            ];

            hydrogenPositions.forEach(pos => {
                const hydrogen = new THREE.Mesh(hydrogenGeometry, hydrogenMaterial);
                hydrogen.position.copy(pos);
                molecule.add(hydrogen);

                const bond = createBond(carbon.position, hydrogen.position);
                molecule.add(bond);
            });

            return molecule;
        }

        function createIon(position = new THREE.Vector3(0, 0, 0), material, charge) {
            const ion = new THREE.Group();
            ion.position.copy(position);

            const sphere = new THREE.Mesh(ionGeometry, material);
            ion.add(sphere);

            const labelSize = 0.4;
            const chargeText = charge > 0 ? `+${charge}` : `${charge}`;

            if (font) {
                const chargeGeometry = new TextGeometry(chargeText, {
                    font: font,
                    size: labelSize,
                    height: labelSize * 0.1,
                    curveSegments: 12,
                    bevelEnabled: false
                });

                const chargeMaterial = new THREE.MeshBasicMaterial({
                    color: charge > 0 ? 0xFF0000 : 0x0000FF
                });

                const chargeMesh = new THREE.Mesh(chargeGeometry, chargeMaterial);
                chargeMesh.position.set(0, 1.5, 0);
                ion.add(chargeMesh);
            }

            return ion;
        }

        function createElectricFieldLines(sourcePosition, targetPosition, numLines = 10, radius = 3, lineColor = 0xFFFFFF) {
            const group = new THREE.Group();
            const direction = new THREE.Vector3().subVectors(targetPosition, sourcePosition).normalize();
            const distance = sourcePosition.distanceTo(targetPosition);

            const perpVec1 = new THREE.Vector3(1, 0, 0);
            if (Math.abs(direction.dot(perpVec1)) > 0.9) {
                perpVec1.set(0, 1, 0);
            }
            const perpVec2 = new THREE.Vector3().crossVectors(direction, perpVec1).normalize();
            perpVec1.crossVectors(perpVec2, direction).normalize();

            for (let i = 0; i < numLines; i++) {
                const angle = (i / numLines) * Math.PI * 2;
                const offset = new THREE.Vector3()
                    .addScaledVector(perpVec1, Math.cos(angle) * radius)
                    .addScaledVector(perpVec2, Math.sin(angle) * radius);

                const start = new THREE.Vector3().copy(sourcePosition).add(offset);
                const control1 = new THREE.Vector3().copy(sourcePosition)
                    .addScaledVector(direction, distance * 0.3)
                    .add(offset.clone().multiplyScalar(0.8));
                const control2 = new THREE.Vector3().copy(targetPosition)
                    .addScaledVector(direction, -distance * 0.3)
                    .add(offset.clone().multiplyScalar(0.4));
                const end = new THREE.Vector3().copy(targetPosition);

                const curve = new THREE.CubicBezierCurve3(start, control1, control2, end);

                const geometry = new THREE.TubeGeometry(curve, 20, 0.05, 8, false);
                const material = new THREE.MeshBasicMaterial({ 
                    color: lineColor,
                    transparent: true,
                    opacity: 0.4
                });

                const mesh = new THREE.Mesh(geometry, material);
                group.add(mesh);
            }

            return group;
        }

        function updateActiveButton(buttonId) {

            document.querySelectorAll('.material-button').forEach(btn => {
                btn.classList.remove('active-button');
            });

            document.getElementById(buttonId).classList.add('active-button');
        }

        function visualizeHydrogenBonding() {
            if (!font) {
                setTimeout(visualizeHydrogenBonding, 100);
                return;
            }

            clearScene();
            currentMode = 'hBond';
            updateActiveButton('hBond');

            document.getElementById('description').textContent = 
                "Hydrogen bonding occurs between a hydrogen atom bonded to a highly electronegative atom (like O, N, F) and another electronegative atom. This is a strong type of dipole-dipole interaction.";

            const water1 = createWaterMolecule(new THREE.Vector3(-3, 0, 0), new THREE.Euler(0, 0, 0));
            moleculeGroup.add(water1);

            const water2 = createWaterMolecule(new THREE.Vector3(3, 0, 0), new THREE.Euler(0, 0, Math.PI));
            moleculeGroup.add(water2);

            const deltaPos1 = new THREE.Mesh(
                new THREE.SphereGeometry(0.3, 16, 16),
                positiveChargeMaterial
            );
            deltaPos1.position.set(-3.8, 0.5, 0);
            moleculeGroup.add(deltaPos1);

            const deltaPos2 = new THREE.Mesh(
                new THREE.SphereGeometry(0.3, 16, 16),
                positiveChargeMaterial
            );
            deltaPos2.position.set(-2.2, 0.5, 0);
            moleculeGroup.add(deltaPos2);

            const deltaNeg1 = new THREE.Mesh(
                new THREE.SphereGeometry(0.4, 16, 16),
                negativeChargeMaterial
            );
            deltaNeg1.position.set(-3, 0, 0);
            moleculeGroup.add(deltaNeg1);

            const deltaPos3 = new THREE.Mesh(
                new THREE.SphereGeometry(0.3, 16, 16),
                positiveChargeMaterial
            );
            deltaPos3.position.set(2.2, -0.5, 0);  
            moleculeGroup.add(deltaPos3);

            const deltaPos4 = new THREE.Mesh(
                new THREE.SphereGeometry(0.3, 16, 16),
                positiveChargeMaterial
            );
            deltaPos4.position.set(3.8, -0.5, 0);  
            moleculeGroup.add(deltaPos4);

            const deltaNeg2 = new THREE.Mesh(
                new THREE.SphereGeometry(0.4, 16, 16),
                negativeChargeMaterial
            );
            deltaNeg2.position.set(3, 0, 0);
            moleculeGroup.add(deltaNeg2);

            const hBond = createDottedBond(
                new THREE.Vector3(-3, 0, 0),  
                new THREE.Vector3(2.2, -0.5, 0)  
            );
            moleculeGroup.add(hBond);

            const textMesh = create3DText("Hydrogen Bond", 0.5, { x: 0, y: 1.5, z: 0 });

            function animate() {
                animationFrameId = requestAnimationFrame(animate);

                animationTime += 0.01;

                updateRainbowEffect(animationTime);

                hBond.children.forEach(segment => {
                    segment.material.opacity = 0.3 + 0.4 * Math.sin(animationTime * 2);
                });

                const distanceOffset = Math.sin(animationTime) * 0.2;
                water1.position.x = -3 + distanceOffset;
                water2.position.x = 3 - distanceOffset;

                deltaPos1.position.x = -3.8 + distanceOffset;
                deltaPos2.position.x = -2.2 + distanceOffset;
                deltaNeg1.position.x = -3 + distanceOffset;

                deltaPos3.position.x = 2.2 - distanceOffset;
                deltaPos4.position.x = 3.8 - distanceOffset;
                deltaNeg2.position.x = 3 - distanceOffset;

                while(hBond.children.length > 0) {
                    hBond.remove(hBond.children[0]);
                }

                const updatedHBond = createDottedBond(
                    new THREE.Vector3(-3 + distanceOffset, 0, 0),
                    new THREE.Vector3(2.2 - distanceOffset, -0.5, 0)
                );

                updatedHBond.children.forEach(segment => {
                    hBond.add(segment);
                });

                controls.update();
                renderer.render(scene, camera);
            }

            animate();
        }

        function visualizeDipoleDipole() {
            if (!font) {
                setTimeout(visualizeDipoleDipole, 100);
                return;
            }

            clearScene();
            currentMode = 'dipole';
            updateActiveButton('dipole');

            document.getElementById('description').textContent = 
                "Dipole-dipole interactions occur between polar molecules. The partially positive end of one molecule is attracted to the partially negative end of another molecule.";

            const water = createWaterMolecule(new THREE.Vector3(-3, 0, 0), new THREE.Euler(0, 0, 0));
            moleculeGroup.add(water);

            const ammonia = createAmmoniaMolecule(new THREE.Vector3(3, 0, 0), new THREE.Euler(Math.PI, 0, 0));
            moleculeGroup.add(ammonia);

            const createArrow = (from, to, color) => {
                const direction = new THREE.Vector3().subVectors(to, from).normalize();
                const arrowLength = 2;
                const arrowHelper = new THREE.ArrowHelper(
                    direction,
                    from,
                    arrowLength,
                    color,
                    0.4,
                    0.3
                );
                return arrowHelper;
            };

            const waterDipole = createArrow(
                new THREE.Vector3(-3, -0.3, 0),  
                new THREE.Vector3(-3, 0.7, 0),   
                0x00FFFF
            );
            arrowHelper.add(waterDipole);

            const ammoniaDipole = createArrow(
                new THREE.Vector3(3, 0.3, 0),    
                new THREE.Vector3(3, -0.7, 0),   
                0xFFFF00
            );
            arrowHelper.add(ammoniaDipole);

            const waterNeg = new THREE.Mesh(
                new THREE.SphereGeometry(0.4, 16, 16),
                negativeChargeMaterial
            );
            waterNeg.position.set(-3, -0.3, 0);  
            moleculeGroup.add(waterNeg);

            const waterPos = new THREE.Mesh(
                new THREE.SphereGeometry(0.4, 16, 16),
                positiveChargeMaterial
            );
            waterPos.position.set(-3, 0.7, 0);  
            moleculeGroup.add(waterPos);

            const ammoniaNeg = new THREE.Mesh(
                new THREE.SphereGeometry(0.4, 16, 16),
                negativeChargeMaterial
            );
            ammoniaNeg.position.set(3, 0.3, 0);  
            moleculeGroup.add(ammoniaNeg);

            const ammoniaPos = new THREE.Mesh(
                new THREE.SphereGeometry(0.4, 16, 16),
                positiveChargeMaterial
            );
            ammoniaPos.position.set(3, -0.7, 0);
            moleculeGroup.add(ammoniaPos);

            const waterDeltaNeg = create3DText("δ-", 0.4, { x: -3, y: -1.5, z: 1 });
            const waterDeltaPos = create3DText("δ+", 0.4, { x: -3, y: 1.5, z: 1 });
            const ammoniaDeltaNeg = create3DText("δ-", 0.4, { x: 3, y: 1.5, z: 1 });
            const ammoniaDeltaPos = create3DText("δ+", 0.4, { x: 3, y: -1.5, z: 1 });

            const interactionGeometry = new THREE.CylinderGeometry(0.05, 0.05, 6, 16);
            interactionGeometry.translate(0, 3, 0);
            const interactionMaterial = new THREE.MeshBasicMaterial({ 
                color: 0xFF00FF, 
                transparent: true, 
                opacity: 0.5
            });

            const interaction = new THREE.Mesh(interactionGeometry, interactionMaterial);
            interaction.position.set(0, 0, 0);
            interaction.rotation.z = Math.PI/2;
            moleculeGroup.add(interaction);

            const dipoleDipoleText = create3DText("Dipole-Dipole Interaction", 0.4, { x: 0, y: 2.5, z: 0 });

            function animate() {
                animationFrameId = requestAnimationFrame(animate);

                animationTime += 0.01;

                updateRainbowEffect(animationTime);

                waterDipole.rotation.z = Math.sin(animationTime) * 0.1;
                ammoniaDipole.rotation.z = Math.sin(animationTime + Math.PI) * 0.1;

                interaction.material.opacity = 0.3 + 0.2 * Math.sin(animationTime * 2);

                const distanceOffset = Math.sin(animationTime) * 0.3;
                water.position.x = -3 + distanceOffset;
                ammonia.position.x = 3 - distanceOffset;

                waterPos.position.x = -3 + distanceOffset;
                waterNeg.position.x = -3 + distanceOffset;
                ammoniaPos.position.x = 3 - distanceOffset;
                ammoniaNeg.position.x = 3 - distanceOffset;

                waterDeltaNeg.position.x = -3 + distanceOffset;
                waterDeltaPos.position.x = -3 + distanceOffset;
                ammoniaDeltaNeg.position.x = 3 - distanceOffset;
                ammoniaDeltaPos.position.x = 3 - distanceOffset;

                waterDipole.position.x = -3 + distanceOffset;
                ammoniaDipole.position.x = 3 - distanceOffset;

                controls.update();
                renderer.render(scene, camera);
            }

            animate();
        }

        function visualizePolarizability() {
            if (!font) {
                setTimeout(visualizePolarizability, 100);
                return;
            }

            clearScene();
            currentMode = 'polarizability';
            updateActiveButton('polarizability');

            document.getElementById('description').textContent = 
                "Polarizability refers to how easily electron clouds can be distorted in response to an external electric field, creating temporary dipoles. Larger atoms/molecules are generally more polarizable.";

            const methane1 = createMethaneMolecule(new THREE.Vector3(-4, 0, 0));
            moleculeGroup.add(methane1);

            const methane2 = createMethaneMolecule(new THREE.Vector3(4, 0, 0));
            moleculeGroup.add(methane2);

            const createElectronCloud = (position, radius, color) => {
                const cloudGeometry = new THREE.SphereGeometry(radius, 32, 32);
                const cloudMaterial = new THREE.MeshStandardMaterial({
                    color: color,
                    transparent: true,
                    opacity: 0.3,
                    metalness: 0.2,
                    roughness: 0.8
                });

                const cloud = new THREE.Mesh(cloudGeometry, cloudMaterial);
                cloud.position.copy(position);
                return cloud;
            };

            const cloud1 = createElectronCloud(new THREE.Vector3(-4, 0, 0), 1.5, 0x0088FF);
            electronCloudGroup.add(cloud1);

            const cloud2 = createElectronCloud(new THREE.Vector3(4, 0, 0), 1.5, 0x0088FF);
            electronCloudGroup.add(cloud2);

            const dipole1 = new THREE.Group();
            const dipole2 = new THREE.Group();

            const positiveEnd1 = new THREE.Mesh(
                new THREE.SphereGeometry(0.4, 16, 16),
                positiveChargeMaterial
            );
            dipole1.add(positiveEnd1);

            const negativeEnd1 = new THREE.Mesh(
                new THREE.SphereGeometry(0.4, 16, 16),
                negativeChargeMaterial
            );
            dipole1.add(negativeEnd1);

            const positiveEnd2 = new THREE.Mesh(
                new THREE.SphereGeometry(0.4, 16, 16),
                positiveChargeMaterial
            );
            dipole2.add(positiveEnd2);

            const negativeEnd2 = new THREE.Mesh(
                new THREE.SphereGeometry(0.4, 16, 16),
                negativeChargeMaterial
            );
            dipole2.add(negativeEnd2);

            dipole1.position.set(-4, 0, 0);
            dipole2.position.set(4, 0, 0);

            moleculeGroup.add(dipole1);
            moleculeGroup.add(dipole2);

            const polarizabilityText = create3DText("Polarizability & Induced Dipoles", 0.3, { x: 0, y: 3, z: 0 });
            const londonText = create3DText("London Dispersion Forces", 0.3, { x: 0, y: -3, z: 0 });

            const attractionGeometry = new THREE.CylinderGeometry(0.05, 0.05, 8, 16);
            attractionGeometry.translate(0, 4, 0);
            const attractionMaterial = new THREE.MeshBasicMaterial({ 
                color: 0xFFAA00, 
                transparent: true, 
                opacity: 0.5
            });

            const attraction = new THREE.Mesh(attractionGeometry, attractionMaterial);
            attraction.position.set(0, 0, 0);
            attraction.rotation.z = Math.PI/2;
            moleculeGroup.add(attraction);

            function animate() {
                animationFrameId = requestAnimationFrame(animate);

                animationTime += 0.01;

                updateRainbowEffect(animationTime);

                const deformFactor = Math.sin(animationTime * 1.5) * 0.3;

                cloud1.scale.set(1 + deformFactor, 1 - deformFactor, 1);
                cloud2.scale.set(1 - deformFactor, 1 + deformFactor, 1);

                positiveEnd1.position.x = -0.8 * deformFactor;
                negativeEnd1.position.x = 0.8 * deformFactor;

                positiveEnd2.position.x = 0.8 * deformFactor;
                negativeEnd2.position.x = -0.8 * deformFactor;

                const opacity = 0.2 + 0.7 * Math.abs(deformFactor / 0.3);
                positiveEnd1.material.opacity = opacity;
                negativeEnd1.material.opacity = opacity;
                positiveEnd2.material.opacity = opacity;
                negativeEnd2.material.opacity = opacity;

                attraction.material.opacity = 0.2 + 0.3 * Math.abs(deformFactor / 0.3);

                const distanceOffset = Math.abs(deformFactor) * 0.5;
                methane1.position.x = -4 + distanceOffset;
                methane2.position.x = 4 - distanceOffset;

                cloud1.position.x = -4 + distanceOffset;
                cloud2.position.x = 4 - distanceOffset;

                dipole1.position.x = -4 + distanceOffset;
                dipole2.position.x = 4 - distanceOffset;

                controls.update();
                renderer.render(scene, camera);
            }

            animate();
        }

        function visualizeIonDipole() {
    if (!font) {
        setTimeout(visualizeIonDipole, 100);
        return;
    }

    clearScene();
    currentMode = 'ionDipole';
    updateActiveButton('ionDipole');

    document.getElementById('description').textContent = 
        "Ion-dipole interactions occur between an ion and a polar molecule. The strength of this interaction depends on the charge of the ion and the dipole moment of the molecule.";

    const sodiumIon = createIon(new THREE.Vector3(-4, 0, 0), sodiumMaterial, 1);
    moleculeGroup.add(sodiumIon);

    const chlorideIon = createIon(new THREE.Vector3(4, 0, 0), chlorideMaterial, -1);
    moleculeGroup.add(chlorideIon);

    const water1 = createWaterMolecule(
        new THREE.Vector3(-2, 0, 0), 
        new THREE.Euler(0, 0, -Math.PI/2) 
    );
    moleculeGroup.add(water1);

    const water2 = createWaterMolecule(
        new THREE.Vector3(2, 0, 0), 
        new THREE.Euler(0, 0, -Math.PI/2) 
    );
    moleculeGroup.add(water2);

    const createArrow = (from, to, color) => {
        const direction = new THREE.Vector3().subVectors(to, from).normalize();
        const arrowLength = 1.5;
        const arrowHelper = new THREE.ArrowHelper(
            direction,
            from,
            arrowLength,
            color,
            0.3,
            0.2
        );
        return arrowHelper;
    };

    const water1Dipole = createArrow(
        new THREE.Vector3(-2, 0, 0),
        new THREE.Vector3(-3, 0, 0),
        0x00FFFF
    );
    arrowHelper.add(water1Dipole);

    const water2Dipole = createArrow(
        new THREE.Vector3(2, 0, 0),
        new THREE.Vector3(3, 0, 0),
        0x00FFFF
    );
    arrowHelper.add(water2Dipole);

    const sodiumLabel = create3DText("Na+", 0.5, { x: -4, y: -1.5, z: 0 });
    const chlorideLabel = create3DText("Cl-", 0.5, { x: 4, y: -1.5, z: 0 });

    const water1Neg = new THREE.Mesh(
        new THREE.SphereGeometry(0.3, 16, 16),
        negativeChargeMaterial
    );
    water1Neg.position.set(-2, 0, 0); 
    moleculeGroup.add(water1Neg);

    const water2Neg = new THREE.Mesh(
        new THREE.SphereGeometry(0.3, 16, 16),
        negativeChargeMaterial
    );
    water2Neg.position.set(2, 0, 0); 
    moleculeGroup.add(water2Neg);

    const fieldLinesNa = createElectricFieldLines(
        new THREE.Vector3(-4, 0, 0),
        new THREE.Vector3(-2, 0, 0),
        8,
        1.2,
        0xFF4400
    );
    electricFieldGroup.add(fieldLinesNa);

    const fieldLinesCl = createElectricFieldLines(
        new THREE.Vector3(4, 0, 0),
        new THREE.Vector3(2, 0.8, 0), 
        8,
        1.2,
        0x44AAFF
    );
    electricFieldGroup.add(fieldLinesCl);

    const ionDipoleText = create3DText("Ion-Dipole Interaction", 0.5, { x: 0, y: 3, z: 0 });
    const waterSolvationText = create3DText("Water Solvating Ions", 0.4, { x: 0, y: -3, z: 0 });

    function animate() {
        animationFrameId = requestAnimationFrame(animate);
        animationTime += 0.01;

        updateRainbowEffect(animationTime);

        const distanceOffset = Math.sin(animationTime) * 0.5;

        water1.position.x = -2 - distanceOffset;
        water1Neg.position.x = -2 - distanceOffset;
        water1Dipole.position.x = -2 - distanceOffset;

        water2.position.x = 2 + distanceOffset;
        water2Neg.position.x = 2 + distanceOffset;
        water2Dipole.position.x = 2 + distanceOffset;

        electricFieldGroup.children.forEach(field => {
            field.children.forEach(line => {
                line.material.opacity = 0.2 + 0.3 * (1 - Math.abs(distanceOffset) / 0.5);
            });
        });

        const scaleFactor = 1 + 0.05 * Math.sin(animationTime * 3);
        sodiumIon.scale.set(scaleFactor, scaleFactor, scaleFactor);
        chlorideIon.scale.set(scaleFactor, scaleFactor, scaleFactor);

        controls.update();
        renderer.render(scene, camera);
    }

    animate();
}

        document.getElementById('hBond').addEventListener('click', visualizeHydrogenBonding);
        document.getElementById('dipole').addEventListener('click', visualizeDipoleDipole);
        document.getElementById('polarizability').addEventListener('click', visualizePolarizability);
        document.getElementById('ionDipole').addEventListener('click', visualizeIonDipole);
        document.getElementById('reset').addEventListener('click', () => {
            camera.position.set(0, 0, 20);
            controls.reset();
        });

        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

        function animate() {
            requestAnimationFrame(animate);
            controls.update();
            renderer.render(scene, camera);
        }
        animate();
    </script>
</body>
</html>